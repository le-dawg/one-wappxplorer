<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAESTE HH Conflict Timeline</title>
    <style>
        /* Material Design 3 Inspired Base Styles & Variables */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-ssys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-shadow: #000000;
            --md-sys-color-inverse-surface: #313033;
            --md-sys-color-inverse-on-surface: #F4EFF4;
            --md-sys-color-inverse-primary: #D0BCFF;

            /* Custom Conflict Colors */
            --conflict-color-1: #FFA500; /* Orange - Finances/Comm */
            --conflict-color-2: #DC143C; /* Crimson - Deposit Advance */
            --conflict-color-3: #20B2AA; /* LightSeaGreen - Refund Dispute */
            --conflict-color-4: #9370DB; /* MediumPurple - Cabinet Access */

            --md-sys-typescale-body-large-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-body-large-font-weight: 400;
            --md-sys-typescale-body-large-font-size: 16px;
            --md-sys-typescale-body-large-line-height: 24px;
            --md-sys-typescale-body-large-letter-spacing: 0.5px;

            --md-sys-typescale-title-medium-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-title-medium-font-weight: 500;
            --md-sys-typescale-title-medium-font-size: 16px;
            --md-sys-typescale-title-medium-line-height: 24px;
            --md-sys-typescale-title-medium-letter-spacing: 0.15px;

            --md-sys-typescale-label-small-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-label-small-font-weight: 500;
            --md-sys-typescale-label-small-font-size: 11px;
            --md-sys-typescale-label-small-line-height: 16px;
            --md-sys-typescale-label-small-letter-spacing: 0.5px;

            --legend-width: 0px; /* Add this new CSS variable */
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
             /* Prevent accidental text selection interfering with drag */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        h1 {
            color: var(--md-sys-color-primary);
            text-align: center;
            margin-bottom: 30px;
        }

        .timeline-container {
            width: 90%;
            max-width: 1000px;
            margin: 40px auto;
            position: relative;
            padding: 30px 0 40px 0; /* Increased top padding for markers */
             /* Prevent accidental dragging of the container */
            -webkit-user-drag: none;
            user-select: none; /* Redundant but safe */
            -webkit-user-select: none;
        }

        .timeline-track {
            width: 100%;
            height: 6px;
            background-color: var(--md-sys-color-surface-variant);
            border-radius: 3px;
            position: relative;
            margin-top: 10px; /* Ensure space below markers */
        }

        /* Style the slider input itself */
        .timeline-slider {
            width: 100%;
            position: absolute;
            /* Center the slider on the track */
            transform: translateY(-65%);
            left: 0;
            margin: 0;
            cursor: grab;
            height: 20px;
            background: transparent;
            z-index: 10;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Slider Thumb Styling */
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--md-sys-color-primary);
            border-radius: 50%;
            cursor: grab;
            /* Adjust margin-top to precisely center thumb on the visual track */
            margin-top: -6px;
            border: 2px solid var(--md-sys-color-on-primary);
            box-shadow: 0 1px 3px var(--md-sys-color-shadow);
        }

        .timeline-slider::-moz-range-thumb {
            width: 14px; /* Adjusted size */
            height: 14px;
            background: var(--md-sys-color-primary);
            border-radius: 50%;
            cursor: grab;
            border: 2px solid var(--md-sys-color-on-primary);
            box-shadow: 0 1px 3px var(--md-sys-color-shadow);
        }

        .timeline-slider:active {
             cursor: grabbing;
        }
         .timeline-slider:active::-webkit-slider-thumb {
             cursor: grabbing;
        }
        .timeline-slider:active::-moz-range-thumb {
             cursor: grabbing;
        }

        /* Marker Styling */
        .timeline-marker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: absolute;
            /* Position markers above the track, aligned with container top padding */
            top: 22px; /* (30px padding - 16px height / 2) */
            transform: translateX(-50%);
            cursor: pointer;
            z-index: 5;
            border: 2px solid var(--md-sys-color-surface);
            box-shadow: 0 1px 2px var(--md-sys-color-shadow);
            transition: transform 0.1s ease-in-out;
        }
        .timeline-marker:hover {
            transform: translateX(-50%) scale(1.2);
        }

        /* Label Styling */
        .timeline-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 15px; /* Space below track */
            font-family: var(--md-sys-typescale-label-small-font-family-name);
            font-weight: var(--md-sys-typescale-label-small-font-weight);
            font-size: var(--md-sys-typescale-label-small-font-size);
            line-height: var(--md-sys-typescale-label-small-line-height);
            letter-spacing: var(--md-sys-typescale-label-small-letter-spacing);
            color: var(--md-sys-color-on-surface-variant);
        }

        /* Legend Styling */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--md-sys-color-shadow);
            z-index: 50;
            font-size: 12px;
            width: fit-content;
        }
        .legend h4 { margin-top: 0; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .legend-color { width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--md-sys-color-outline); }

        /* Persistent Summary Display */
        .summary-display {
            width: 90%;
            max-width: 1000px;
            margin: 20px auto;
            padding: 24px;
            background-color: var(--md-sys-color-surface);
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-family: var(--md-sys-typescale-body-large-font-family-name);
            font-size: var(--md-sys-typescale-body-large-font-size);
            line-height: 1.6;
            color: var(--md-sys-color-on-surface);
        }

        .summary-display h3 {
            color: var(--md-sys-color-primary);
            margin-top: 0;
            margin-bottom: 16px;
        }

        .summary-display p {
            margin-bottom: 12px;
        }

        .summary-display strong {
            color: var(--md-sys-color-secondary);
        }

        /* Info Box Styling */
        .info-box-2 {
            position: fixed;
            bottom: 437px; /* Position above legend */
            left: 20px;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            padding: 0px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--md-sys-color-shadow);
            z-index: 50;
            font-size: 12px;
            width: var(--legend-width, fit-content);
        }
        
        .info-box {
            position: fixed;
            bottom: 170px; /* Position above legend */
            left: 20px;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            padding: 15px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--md-sys-color-shadow);
            z-index: 50;
            font-size: 12px;
            width: var(--legend-width, fit-content);
        }
        .info-box h3 { 
            margin-top: 0; 
            margin-bottom: 8px; 
            font-size: 14px; 
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }

        /* Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: var(--md-sys-color-surface);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .modal-button {
            padding: 10px 20px;
            background: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 15px;
        }

        /* Hide swipe instruction by default (for desktop) */
        @media (min-width: 769px) {
            .swipe-instruction {
                display: none;
                text-align: center;
                color: var(--md-sys-color-on-surface-variant);
                font-size: 18px !important;
                margin: 10px auto;
                font-weight: normal;
            }
        }

        /* Mobile Responsiveness */
        @media (max-width: 1586px) {
            .legend {
                position: static;
                margin: 20px auto;
                width: 90%;
                max-width: 600px;
            }
            .legend-item {
                margin: 0;
                padding: 5px 10px;
            }
            
            .info-box-2,
            .info-box {
                position: static;
                margin: 20px auto;
                width: 90%;
                max-width: 600px;
            }

            /* Enhance slider for touch */
            .timeline-slider {
                height: 44px; /* Larger touch target */
            }
            .timeline-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
            .timeline-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            /* Show swipe instruction on mobile */
            .swipe-instruction {
                display: block !important; /* Use !important to ensure override */
            }
        }
    </style>
</head>
<body>

    <div class="modal-overlay" id="startModal">
        <div class="modal-content">
            <h2>Welcome</h2>
            <p>Click to enable audio features</p>
            <button class="modal-button" onclick="handleStart()">Start</button>
        </div>
    </div>

    <h1>IAESTE Hamburg Conflict Timeline</h1>

    <div class="legend" id="legend">
        <h4>Color Coded Legend</h4>
        <!-- Legend items added by JS -->
    </div>

    <h3 class="swipe-instruction">Swipe &lt;-&gt; for prev/next entry</h3>

    <div class="timeline-container">
        <div class="timeline-track">
            <!-- Markers will be added here by JS -->
        </div>
         <input type="range" min="0" max="1000" value="0" class="timeline-slider" id="timelineSlider">
         <div class="timeline-labels">
             <span id="startDateLabel">Jun 2024</span>
             <span id="endDateLabel">Apr 2025</span>
         </div>
    </div>

    <div class="summary-display" id="summaryDisplay">
        <!-- Summary content will be added here by JS -->
    </div>

    <div class="info-box-2">
        <h3>Usage</h3>
        <ul>
            <li>Use the slider to navigate through the timeline.</li>
            <li>Click on markers if lazy or drunk.</li>
            <li>Swipe left/right on mobile for quick navigation.</li>
            <li>If keys aren't working, drag the slider once to initialize.</li>
        </ul>
    </div>

    <div class="info-box">
        <h3>About this app</h3>
        This app is an artefact to help others understand my perspective on aspects of this conflict. This is my final take, none of it is up for discussion. It has cost me a lot of time, energy and by way of being mind-raped by both parties and losing focus, substantial amounts of money. Compensating for and translating between people who have opposing coping mechanisms is a bit much to ask, if neither side is willing to adapt.
    </div>

    <script>
        // Detect touch capability once at startup
        const hasTouchInput = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        
        // If not a touch device, hide modal immediately
        if (!hasTouchInput) {
            document.getElementById('startModal').style.display = 'none';
        }
        
        async function handleStart() {
            if (hasTouchInput) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(audioContext.createMediaStreamDestination());
                } catch (err) {
                    window.location.href = 'https://www.disney.com';
                    return;
                }
            }
            document.getElementById('startModal').style.display = 'none';
        }

        const conflictData = [
             {
                id: 1,
                title: "Intern Finances & Communication",
                keyDates: ["2024-09-12", "2024-12-06", "2024-12-16", "2025-02-05"],
                summary: `
                    <h3>Intern Finances (Fortune) & Communication Styles (Sept '24 - Dec '24)</h3>
                    <p><strong>Description:</strong> Disagreement over whether intern Fortune had sufficient funds due to stipend payout method, escalating into accusations about financial responsibility and communication styles.</p>
                    <p><strong>D.'s View:</strong> Believed intern faced hardship (€50 left after expenses), felt S. lacked human consideration/communication, later emphasized intern's shyness and difficult circumstances (broken phone).</p>
                    <p><strong>S.'s View:</strong> Followed procedure based on intern's non-response, felt unfairly accused of wrongdoing (embezzlement), emphasized financial accuracy and procedure, provided evidence of payout amount (€350), stated intern spending is outside LC responsibility.</p>
                    <p><strong>Dawid Position:</strong> The concern for financial hardship for Fortune was valid. Due to over-the-top emotional response by Finance we never took the time to actually figure out if there was financial hardship. It was a blame game from day one and even I was targeted.</p>
                    <p><strong>Dawid demands for the future:</strong>It is the person that is working most closely with the intern that makes the judgement call on this and all other issues regarding what the intern might need to have a good stay here. Finance does not get to make moral judgement calls. Interns should get whatever is left from the monthly payout after subtracting all expenses (Rent, Kaution, DE Ticket, etc.) - I hope that is obvious to everyone?. If we need to codify this - let's do it. If this is too much for Finance to handle and should be done by some with more of a human touch - then we codify that and put this in the Knowledge Base.</p>
                `,
                color: "var(--conflict-color-1)" // Orange
            },
            {
                id: 2,
                title: "Intern Deposit Advance",
                keyDates: ["2024-09-18", "2024-09-19", "2024-09-20", "2024-09-21", "2024-09-25", "2024-11-10", "2025-01-27", "2025-01-30", "2025-03-30", "2025-03-31", "2025-04-01"],
                summary: `
                    <h3>Intern Deposit Handling (Siham/Lucia, Geysa, Mohamed) & Trust (Sept '24 - Apr '25)</h3>
                    <p><strong>Description:</strong> Recurring conflicts over handling intern security deposits, involving timing (advance payout vs. waiting for landlord return), risk, trust, communication, and differing views on standard procedure.</p>
                    <p><strong>D.'s View:</strong> Emphasized interns' immediate needs (travel money, banking issues), felt pressured, sometimes advanced funds (claiming consultation/necessity), felt blamed for issues, highlighted lack of clear/timely communication from S. on procedure.</p>
                    <p><strong>S.'s View:</strong> Stressed LC can't return funds not yet received, procedure (contract/inspection) is key, early payout is risky, stated standard procedure involves landlord/intern direct handling where possible, communicated this but felt ignored or communication was unclear.</p>
                    <p><strong>Dawid's position:</strong> We as an LC were taken advantage of here - obviously we can't pay something back the we did not receive. The interns knew they fucked up and knew they would have issues, and perhaps even planned their travel to force a situation like this.</p>
                    <p><strong>Dawid's demands for the future:</strong> We should codify that interns do not get deposits back early, no matter what. Only the actual landlords decide, and give us in writing, that. Sadly, with how flexible and unpredictable the business of dealing with interns is, this might be too strict. Still, if we can't be flexible due to people not being able to talk and adapt quickly, that is how it is. </p>
                `,
                color: "var(--conflict-color-2)" // Crimson
            },
            {
                id: 3,
                title: "Expense Refund Dispute",
                keyDates: ["2024-10-23", "2024-10-28", "2024-11-10", "2025-01-16", "2025-01-17", "2025-02-04", "2025-02-05", "2025-03-11", "2025-04-01", "2025-04-02"],
                summary: `
                    <h3>Expense Refund Dispute (Gifts, Food, Supplies) (Oct '24 - Apr '25)</h3>
                    <p><strong>Description:</strong> S. delayed/denied refunding D. for small expenses (conference gift, intern fish sandwiches, JYSK supplies, sponges), citing lack of prior approval, unresolved personal conflict, and questioning LC benefit.</p>
                    <p><strong>D.'s View:</strong> Expenses were legitimate LC costs (representation, intern activity, supplies), felt refund unfairly withheld due to personal animosity, provided proof of asking, compared negatively to previous treasurer.</p>
                    <p><strong>S.'s View:</strong> Linked cooperation/refund to conflict resolution, enforced boundary due to feeling hurt, questioned procedure (prior agreement needed), eventually needed IBAN, contested some small amounts.</p>
                    <p><strong>Dawg's position:</strong> Yeah, clear abuse of power by S. and unnecessary unprofessional communication by D. ("fuck off"). I feel manipulated and mind-raped for letting this slide. The expenses (STILL NOT PAID MORE THAN 6 MONTHS LATER) were trivial in amount, were clearly demanded from DAAD and all the power plays around not returning them were downright toxic and manipulative. I will not be able to unsee this.</p>
                    <p><strong>Dawg's demands for the future:</strong>What can I say, it should be obvious: 1) don't resort to "fuck off" language. There are polite ways to insult people. Learn them. You will need them on the job - most likely. 2) Accept what I say. The money should be returned ASAP with a formal apology for abusing power (because abusing formal power is an official act, I demand an apology). This might lead to a "But I did not get an apology for October mimimi." Fuck that - official power abuse -> apology. Private insults -> figure it out yourselves and don't affect LC operations.</p>
                `, 
                color: "var(--conflict-color-3)" // LightSeaGreen
            },
            {
                id: 4,
                title: "Storage Cabinet Access",
                keyDates: ["2024-11-28", "2024-12-12", "2024-12-13", "2024-12-16", "2024-12-17", "2024-12-18"],
                summary: `
                    <h3>Storage Cabinet (Schrank) Access (Nov '24 - Dec '24)</h3>
                    <p><strong>Description:</strong> D. demanded access to shared IAESTE cabinet controlled by S., who restricted access citing personal items stored within and unresolved conflict.</p>
                    <p><strong>D.'s View:</strong> Needed access to LC merchandise for planning/activities, saw refusal as misuse of LC property for personal reasons, rejected compromises (list), felt stonewalled.</p>
                    <p><strong>S.'s View:</strong> Didn't trust D. near personal items due to past conflict, offered compromises but refused full access until conflict resolved, perceived demands as pressure/disrespect ("rapist mindset"), accused her of hypocrisy.</p>
                    <p><strong>Dawg's position:</strong> This felt like a "afraid of D. abusing information about personal stuff mixed with official stuff" thing. I will say what I have been thinking for months: this feels like S. personal insecurity. I don't have a problem with it. </p>
                    <p><strong>Dawg's demands for the future:</strong>Do we need to codify that mixed use (priv/official) is OK, normal and done by everone at TUHH and everywhere else? No bigotry, same rules for everyone. Aside from that: letting personal insecurities stand in the way of legitimate LC interests is a MAJOR drag on my mind. Judgement by others happens all the time, coping with that is everyone's personal journey. If there is internalized traumatic stuff around being judged or whatever, seek therapy. I did, and it works.</p>
                `,
                color: "var(--conflict-color-4)" // MediumPurple
            }
        ];

        const timelineContainer = document.querySelector('.timeline-container');
        const timelineTrack = timelineContainer.querySelector('.timeline-track');
        const slider = document.getElementById('timelineSlider');
        const legend = document.getElementById('legend');
        const startDateLabel = document.getElementById('startDateLabel');
        const endDateLabel = document.getElementById('endDateLabel');

        let markerData = []; // To store marker positions and associated conflict IDs

        function initializeTimeline() {
            // Clear previous markers if any
            timelineTrack.innerHTML = '';
            markerData = []; // Reset marker data

            // --- Date Range Calculation ---
            let allDates = conflictData.flatMap(c => c.keyDates.map(d => new Date(d).getTime()));
            if (allDates.length === 0) { // Handle case with no dates
                allDates = [new Date("2024-06-01").getTime(), new Date("2025-04-06").getTime()];
            }
            const minTimestamp = Math.min(...allDates);
            const maxTimestamp = Math.max(...allDates);

            const timelineStart = new Date(minTimestamp);
            timelineStart.setDate(1); // Start timeline at the beginning of the first conflict month
            timelineStart.setMonth(timelineStart.getMonth()); // Keep the month

            const timelineEnd = new Date(maxTimestamp);
            timelineEnd.setDate(1); // End timeline at the beginning of the month *after* the last conflict
            timelineEnd.setMonth(timelineEnd.getMonth() + 1);


            const totalDuration = timelineEnd.getTime() - timelineStart.getTime();

            // Update timeline labels
            const formatDateLabel = (date) => date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            startDateLabel.textContent = formatDateLabel(timelineStart);
            endDateLabel.textContent = formatDateLabel(timelineEnd);

            // --- Populate Legend ---
            legend.innerHTML = '<h4>Color Coded Legend</h4>'; // Reset header
            conflictData.forEach(conflict => {
                const item = document.createElement('div');
                item.classList.add('legend-item');
                item.innerHTML = `
                    <span class="legend-color" style="background-color: ${conflict.color};"></span>
                    ${conflict.title}
                `;
                legend.appendChild(item);
            });

            // --- Create Markers ---
            conflictData.forEach(conflict => {
                conflict.keyDates.forEach((dateStr) => {
                    const date = new Date(dateStr);
                    const datePos = date.getTime() - timelineStart.getTime();
                    // Ensure division by zero doesn't happen if duration is 0
                    const percentage = totalDuration > 0 ? (datePos / totalDuration) * 100 : 0;

                    if (percentage >= 0 && percentage <= 100) {
                        // Store marker data for snapping
                        markerData.push({ percent: percentage, conflictId: conflict.id });

                        const marker = document.createElement('div');
                        marker.classList.add('timeline-marker');
                        marker.style.left = `${percentage}%`;
                        marker.style.backgroundColor = conflict.color;
                        marker.dataset.conflictId = conflict.id;
                        marker.dataset.date = dateStr;

                        timelineTrack.appendChild(marker);

                        // Add hover and click listeners to markers
                        marker.addEventListener('mouseenter', (event) => {
                            const conflict = conflictData.find(c => c.id === parseInt(event.target.dataset.conflictId));
                            if (conflict) {
                                const date = event.target.dataset.date;
                                updateDisplays(conflict, date);
                            }
                        });

                        // Add click/tap handler
                        marker.addEventListener('click', (event) => {
                            const conflict = conflictData.find(c => c.id === parseInt(event.target.dataset.conflictId));
                            if (conflict) {
                                const date = event.target.dataset.date;
                                updateDisplays(conflict, date);
                                // Update slider position to match clicked marker
                                slider.value = Math.round(percentage * 10.0);
                            }
                        });
                    }
                });
            });
             // Sort marker data by percentage for easier snapping calculation
             markerData.sort((a, b) => a.percent - b.percent);
            
            // Start with slider at 0 instead of snapping to first marker
            slider.value = 0;
            updateDisplays(null); // Clear displays initially

            // Start with first marker's data if available
            if (markerData.length > 0) {
                const firstMarker = markerData[0];
                const firstConflict = conflictData.find(c => c.id === firstMarker.conflictId);
                if (firstConflict) {
                    updateDisplays(firstConflict, firstConflict.keyDates[0]);
                    slider.value = Math.round(firstMarker.percent * 10.0);
                }
            }
        }

        function updateDisplays(conflict, date = null) {
            const summaryDisplay = document.getElementById('summaryDisplay');

            if (conflict) {
                summaryDisplay.innerHTML = conflict.summary + `
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--md-sys-color-outline);">
                        <strong>Key Dates:</strong> ${conflict.keyDates.map(d => new Date(d).toLocaleDateString('en-US', { 
                            year: 'numeric', 
                            month: 'short', 
                            day: 'numeric' 
                        })).join(', ')}
                    </div>`;
            } else {
                summaryDisplay.innerHTML = '<p>Move the slider to a marker to see conflict details.</p><p> Use the arrow keys to quickly iterate over the date markers.</p>';
            }
        }

        // --- Slider Interaction ---
        slider.addEventListener('input', (event) => {
            const sliderValue = parseFloat(slider.value);
            const sliderPercent = sliderValue / 10.0;
            let closestMarker = null;
            let minDistance = Infinity;

            for (const markerInfo of markerData) {
                const distance = Math.abs(sliderPercent - markerInfo.percent);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMarker = markerInfo;
                }
            }

            if (closestMarker && minDistance < 2.0) {
                const conflict = conflictData.find(c => c.id === closestMarker.conflictId);
                if (conflict) {
                    const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${closestMarker.percent}%"]`);
                    const date = marker ? marker.dataset.date : null;
                    updateDisplays(conflict, date);
                }
            } else {
                updateDisplays(null);
            }
        });

        slider.addEventListener('change', () => {
            const sliderValue = parseFloat(slider.value);
            const currentPercent = sliderValue / 10.0;
            let closestMarkerPercent = markerData[0].percent; // Default to first marker
            let minDistance = Math.abs(currentPercent - markerData[0].percent);

            // Find the closest marker
            markerData.forEach(markerInfo => {
                const distance = Math.abs(currentPercent - markerInfo.percent);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMarkerPercent = markerInfo.percent;
                }
            });

            // Always snap to closest marker
            const snappedValue = Math.round(closestMarkerPercent * 10.0);
            slider.value = snappedValue;

            // Show summary for snapped position
            const snappedPercent = snappedValue / 10.0;
            const markerInfo = markerData.find(m => Math.abs(m.percent - snappedPercent) < 0.1);
            if (markerInfo) {
                const conflict = conflictData.find(c => c.id === markerInfo.conflictId);
                if (conflict) {
                    const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${markerInfo.percent}%"]`);
                    const date = marker ? marker.dataset.date : null;
                    updateDisplays(conflict, date);
                }
            }
        });

        slider.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                
                const currentValue = parseFloat(slider.value);
                const currentPercent = currentValue / 10.0;
                
                let nextMarker;
                if (event.key === 'ArrowRight') {
                    nextMarker = markerData.find(marker => marker.percent > currentPercent + 0.1);
                    if (!nextMarker && currentPercent < 0.1) {
                        nextMarker = markerData[0];
                    }
                } else {
                    nextMarker = markerData.reverse().find(marker => marker.percent < currentPercent - 0.1);
                    markerData.reverse();
                    if (!nextMarker && currentPercent > 99.9) {
                        nextMarker = markerData[markerData.length - 1];
                    }
                }

                if (nextMarker) {
                    slider.value = Math.round(nextMarker.percent * 10.0);
                    const conflict = conflictData.find(c => c.id === nextMarker.conflictId);
                    if (conflict) {
                        const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${nextMarker.percent}%"]`);
                        const date = marker ? marker.dataset.date : null;
                        updateDisplays(conflict, date);
                    }
                }
            }
        });

        // Add touch swipe handling
        let touchStartX = 0;
        let touchEndX = 0;
        
        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        }, false);
        
        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, false);
        
        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchEndX - touchStartX;
            
            if (Math.abs(diff) < swipeThreshold) return;
            
            // Simulate arrow key press based on swipe direction
            const event = new KeyboardEvent('keydown', {
                key: diff > 0 ? 'ArrowLeft' : 'ArrowRight'
            });
            slider.dispatchEvent(event);
        }

        // Create ResizeObserver to track legend width changes
        const legendObserver = new ResizeObserver(entries => {
            for (const entry of entries) {
                const width = entry.contentRect.width;
                document.documentElement.style.setProperty('--legend-width', width + 'px');
            }
        });

        // Start observing the legend element
        const legendElement = document.querySelector('.legend');
        legendObserver.observe(legendElement);

        // Initialize timeline
        initializeTimeline();

        // Re-initialize on window resize to adjust marker positions
        window.addEventListener('resize', initializeTimeline);
    </script>

</body>
</html>
