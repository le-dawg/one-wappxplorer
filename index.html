<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IAESTE HH Conflict Timeline</title>
    <style>
        /* Material Design 3 Inspired Base Styles & Variables */
        :root {
            --md-sys-color-primary: #6750A4;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #EADDFF;
            --md-sys-color-on-primary-container: #21005D;
            --md-sys-color-secondary: #625B71;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-ssys-color-secondary-container: #E8DEF8;
            --md-sys-color-on-secondary-container: #1D192B;
            --md-sys-color-tertiary: #7D5260;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #FFD8E4;
            --md-sys-color-on-tertiary-container: #31111D;
            --md-sys-color-error: #B3261E;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #F9DEDC;
            --md-sys-color-on-error-container: #410E0B;
            --md-sys-color-background: #FFFBFE;
            --md-sys-color-on-background: #1C1B1F;
            --md-sys-color-surface: #FFFBFE;
            --md-sys-color-on-surface: #1C1B1F;
            --md-sys-color-surface-variant: #E7E0EC;
            --md-sys-color-on-surface-variant: #49454F;
            --md-sys-color-outline: #79747E;
            --md-sys-color-shadow: #000000;
            --md-sys-color-inverse-surface: #313033;
            --md-sys-color-inverse-on-surface: #F4EFF4;
            --md-sys-color-inverse-primary: #D0BCFF;

            /* Custom Conflict Colors */
            --conflict-color-1: #FFA500; /* Orange - Finances/Comm */
            --conflict-color-2: #DC143C; /* Crimson - Deposit Advance */
            --conflict-color-3: #20B2AA; /* LightSeaGreen - Refund Dispute */
            --conflict-color-4: #9370DB; /* MediumPurple - Cabinet Access */

            --md-sys-typescale-body-large-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-body-large-font-weight: 400;
            --md-sys-typescale-body-large-font-size: 16px;
            --md-sys-typescale-body-large-line-height: 24px;
            --md-sys-typescale-body-large-letter-spacing: 0.5px;

            --md-sys-typescale-title-medium-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-title-medium-font-weight: 500;
            --md-sys-typescale-title-medium-font-size: 16px;
            --md-sys-typescale-title-medium-line-height: 24px;
            --md-sys-typescale-title-medium-letter-spacing: 0.15px;

            --md-sys-typescale-label-small-font-family-name: 'Roboto', sans-serif;
            --md-sys-typescale-label-small-font-weight: 500;
            --md-sys-typescale-label-small-font-size: 11px;
            --md-sys-typescale-label-small-line-height: 16px;
            --md-sys-typescale-label-small-letter-spacing: 0.5px;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
             /* Prevent accidental text selection interfering with drag */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        h1 {
            color: var(--md-sys-color-primary);
            text-align: center;
            margin-bottom: 30px;
        }

        .timeline-container {
            width: 90%;
            max-width: 1000px;
            margin: 40px auto;
            position: relative;
            padding: 30px 0 40px 0; /* Increased top padding for markers */
             /* Prevent accidental dragging of the container */
            -webkit-user-drag: none;
            user-select: none; /* Redundant but safe */
            -webkit-user-select: none;
        }

        .timeline-track {
            width: 100%;
            height: 6px;
            background-color: var(--md-sys-color-surface-variant);
            border-radius: 3px;
            position: relative;
            margin-top: 10px; /* Ensure space below markers */
        }

        /* Style the slider input itself */
        .timeline-slider {
            width: 100%;
            position: absolute;
            /* Center the slider on the track */
            top: 50%;
            transform: translateY(-50%);
            left: 0;
            margin: 0;
            cursor: grab;
            height: 20px;
            background: transparent;
            z-index: 10;
            -webkit-appearance: none;
            appearance: none;
        }

        /* Slider Thumb Styling */
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--md-sys-color-primary);
            border-radius: 50%;
            cursor: grab;
            /* Adjust margin-top to precisely center thumb on the visual track */
            margin-top: -6px;
            border: 2px solid var(--md-sys-color-on-primary);
            box-shadow: 0 1px 3px var(--md-sys-color-shadow);
        }

        .timeline-slider::-moz-range-thumb {
            width: 14px; /* Adjusted size */
            height: 14px;
            background: var(--md-sys-color-primary);
            border-radius: 50%;
            cursor: grab;
            border: 2px solid var(--md-sys-color-on-primary);
            box-shadow: 0 1px 3px var(--md-sys-color-shadow);
        }

        .timeline-slider:active {
             cursor: grabbing;
        }
         .timeline-slider:active::-webkit-slider-thumb {
             cursor: grabbing;
        }
        .timeline-slider:active::-moz-range-thumb {
             cursor: grabbing;
        }

        /* Marker Styling */
        .timeline-marker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: absolute;
            /* Position markers above the track, aligned with container top padding */
            top: 22px; /* (30px padding - 16px height / 2) */
            transform: translateX(-50%);
            cursor: pointer;
            z-index: 5;
            border: 2px solid var(--md-sys-color-surface);
            box-shadow: 0 1px 2px var(--md-sys-color-shadow);
            transition: transform 0.1s ease-in-out;
        }
        .timeline-marker:hover {
            transform: translateX(-50%) scale(1.2);
        }

        /* Label Styling */
        .timeline-labels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 15px; /* Space below track */
            font-family: var(--md-sys-typescale-label-small-font-family-name);
            font-weight: var(--md-sys-typescale-label-small-font-weight);
            font-size: var(--md-sys-typescale-label-small-font-size);
            line-height: var(--md-sys-typescale-label-small-line-height);
            letter-spacing: var(--md-sys-typescale-label-small-letter-spacing);
            color: var(--md-sys-color-on-surface-variant);
        }

        /* Legend Styling */
        .legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--md-sys-color-shadow);
            z-index: 50;
            font-size: 12px;
        }
        .legend h4 { margin-top: 0; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .legend-color { width: 14px; height: 14px; border-radius: 50%; margin-right: 8px; border: 1px solid var(--md-sys-color-outline); }

        /* Persistent Summary Display */
        .summary-display {
            width: 90%;
            max-width: 1000px;
            margin: 20px auto;
            padding: 24px;
            background-color: var(--md-sys-color-surface);
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-family: var(--md-sys-typescale-body-large-font-family-name);
            font-size: var(--md-sys-typescale-body-large-font-size);
            line-height: 1.6;
            color: var(--md-sys-color-on-surface);
        }

        .summary-display h3 {
            color: var(--md-sys-color-primary);
            margin-top: 0;
            margin-bottom: 16px;
        }

        .summary-display p {
            margin-bottom: 12px;
        }

        .summary-display strong {
            color: var(--md-sys-color-secondary);
        }

        /* Info Box Styling */
        .info-box {
            position: fixed;
            bottom: 140px; /* Position above legend */
            left: 20px;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--md-sys-color-shadow);
            z-index: 50;
            font-size: 12px;
            max-width: 300px;
            line-height: 1.4;
        }
        .info-box h3 { 
            margin-top: 0; 
            margin-bottom: 8px; 
            font-size: 14px; 
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }

        /* Hide swipe instruction by default (for desktop) */
        @media (min-width: 769px) {
            .swipe-instruction {
                display: none;
                text-align: center;
                color: var(--md-sys-color-on-surface-variant);
                font-size: 18px !important;
                margin: 10px auto;
                font-weight: normal;
            }
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .legend {
                position: static;
                margin: 20px auto;
                width: 90%;
                max-width: 600px;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
                background-color: var(--md-sys-color-surface);
            }
            .legend-item {
                margin: 0;
                padding: 5px 10px;
            }
            
            .info-box {
                position: static;
                margin: 20px auto;
                width: 90%;
                max-width: 600px;
            }

            /* Enhance slider for touch */
            .timeline-slider {
                height: 44px; /* Larger touch target */
            }
            .timeline-slider::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }
            .timeline-slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            /* Show swipe instruction on mobile */
            .swipe-instruction {
                display: block !important; /* Use !important to ensure override */
            }
        }
    </style>
</head>
<body>

    <h1>IAESTE Hamburg Conflict Timeline</h1>

    <div class="legend" id="legend">
        <h4>Color Coded Legend</h4>
        <!-- Legend items added by JS -->
    </div>

    <h3 class="swipe-instruction">Swipe &lt;-&gt; for prev/next entry</h3>

    <div class="timeline-container">
        <div class="timeline-track">
            <!-- Markers will be added here by JS -->
        </div>
         <input type="range" min="0" max="1000" value="0" class="timeline-slider" id="timelineSlider">
         <div class="timeline-labels">
             <span id="startDateLabel">Jun 2024</span>
             <span id="endDateLabel">Apr 2025</span>
         </div>
    </div>

    <div class="summary-display" id="summaryDisplay">
        <!-- Summary content will be added here by JS -->
    </div>

    <div class="info-box">
        <h3>About this app</h3>
        This app is an artefact to help others understand my perspective on aspects of this conflict. This is my final take, none of it is up for discussion. It has cost me a lot of time, energy and by way of being mind-raped by both parties and losing focus, substantial amounts of money to compensate for and translate between two people who have opposing coping mechanisms.
    </div>

    <script>
        const conflictData = [
             {
                id: 1,
                title: "Intern Finances & Communication",
                keyDates: ["2024-09-12", "2024-12-06", "2024-12-16", "2025-02-05"],
                summary: `
                    <h3>Intern Finances (Fortune) & Communication Styles (Sept '24 - Dec '24)</h3>
                    <p><strong>Description:</strong> Disagreement over whether intern Fortune had sufficient funds due to stipend payout method, escalating into accusations about financial responsibility and communication styles.</p>
                    <p><strong>Domasan PL's View:</strong> Believed intern faced hardship (€50 left after expenses), felt Stephan lacked human consideration/communication, later emphasized intern's shyness and difficult circumstances (broken phone).</p>
                    <p><strong>Stephan rakke's View:</strong> Followed procedure based on intern's non-response, felt unfairly accused of wrongdoing (embezzlement), emphasized financial accuracy and procedure, provided evidence of payout amount (€350), stated intern spending is outside LC responsibility.</p>
                    <p><strong>Dawg's Insights:</strong> Acknowledged hardship concern, tried de-escalation, noted communication breakdown, stressed need for clear policy vs. personal bias.</p>
                `,
                color: "var(--conflict-color-1)" // Orange
            },
            {
                id: 2,
                title: "Intern Deposit Advance",
                keyDates: ["2024-09-18", "2024-09-19", "2024-09-20", "2024-09-21", "2024-09-25", "2024-11-10", "2025-01-27", "2025-01-30", "2025-03-30", "2025-03-31", "2025-04-01"],
                summary: `
                    <h3>Intern Deposit Handling (Siham/Lucia, Geysa, Mohamed) & Trust (Sept '24 - Apr '25)</h3>
                    <p><strong>Description:</strong> Recurring conflicts over handling intern security deposits, involving timing (advance payout vs. waiting for landlord return), risk, trust, communication, and differing views on standard procedure.</p>
                    <p><strong>Domasan PL's View:</strong> Emphasized interns' immediate needs (travel money, banking issues), felt pressured, sometimes advanced funds (claiming consultation/necessity), felt blamed for issues, highlighted lack of clear/timely communication from Stephan on procedure.</p>
                    <p><strong>Stephan rakke's View:</strong> Stressed LC can't return funds not yet received, procedure (contract/inspection) is key, early payout is risky, stated standard procedure involves landlord/intern direct handling where possible, communicated this but felt ignored or communication was unclear.</p>
                    <p><strong>Dawg's Insights:</strong> Acknowledged validity of both sides, suggested inspection (Protokoll) to mitigate risk, expressed frustration at recurring issue.</p>
                `,
                color: "var(--conflict-color-2)" // Crimson
            },
            {
                id: 3,
                title: "Expense Refund Dispute",
                keyDates: ["2024-10-23", "2024-10-28", "2024-11-10", "2025-01-16", "2025-01-17", "2025-02-04", "2025-02-05", "2025-03-11", "2025-04-01", "2025-04-02"],
                summary: `
                    <h3>Expense Refund Dispute (Gifts, Food, Supplies) (Oct '24 - Apr '25)</h3>
                    <p><strong>Description:</strong> Stephan delayed/denied refunding Domasan PL for small expenses (conference gift, intern fish sandwiches, JYSK supplies, sponges), citing lack of prior approval, unresolved personal conflict, and questioning LC benefit.</p>
                    <p><strong>Domasan PL's View:</strong> Expenses were legitimate LC costs (representation, intern activity, supplies), felt refund unfairly withheld due to personal animosity, provided proof of asking, compared negatively to previous treasurer.</p>
                    <p><strong>Stephan rakke's View:</strong> Linked cooperation/refund to conflict resolution, enforced boundary due to feeling hurt, questioned procedure (prior agreement needed), eventually needed IBAN, contested some small amounts.</p>
                    <p><strong>Dawg's Insights:</strong> Viewed amounts as trivial, considered expenses legitimate, frustrated by personal issues blocking LC functions, demanded resolution and fund transfer.</p>
                `,
                color: "var(--conflict-color-3)" // LightSeaGreen
            },
            {
                id: 4,
                title: "Storage Cabinet Access",
                keyDates: ["2024-11-28", "2024-12-12", "2024-12-13", "2024-12-16", "2024-12-17", "2024-12-18"],
                summary: `
                    <h3>Storage Cabinet (Schrank) Access (Nov '24 - Dec '24)</h3>
                    <p><strong>Description:</strong> Domasan PL demanded access to shared IAESTE cabinet controlled by Stephan, who restricted access citing personal items stored within and unresolved conflict.</p>
                    <p><strong>Domasan PL's View:</strong> Needed access to LC merchandise for planning/activities, saw refusal as misuse of LC property for personal reasons, rejected compromises (list), felt stonewalled.</p>
                    <p><strong>Stephan rakke's View:</strong> Didn't trust Domasan near personal items due to past conflict, offered compromises but refused full access until conflict resolved, perceived demands as pressure/disrespect ("rapist mindset"), accused her of hypocrisy.</p>
                    <p><strong>Dawg's Insights:</strong> General calls for conflict resolution apply.</p>
                `,
                color: "var(--conflict-color-4)" // MediumPurple
            }
        ];

        const timelineContainer = document.querySelector('.timeline-container');
        const timelineTrack = timelineContainer.querySelector('.timeline-track');
        const slider = document.getElementById('timelineSlider');
        const legend = document.getElementById('legend');
        const startDateLabel = document.getElementById('startDateLabel');
        const endDateLabel = document.getElementById('endDateLabel');

        let markerData = []; // To store marker positions and associated conflict IDs

        function initializeTimeline() {
            // Clear previous markers if any
            timelineTrack.innerHTML = '';
            markerData = []; // Reset marker data

            // --- Date Range Calculation ---
            let allDates = conflictData.flatMap(c => c.keyDates.map(d => new Date(d).getTime()));
            if (allDates.length === 0) { // Handle case with no dates
                allDates = [new Date("2024-06-01").getTime(), new Date("2025-04-06").getTime()];
            }
            const minTimestamp = Math.min(...allDates);
            const maxTimestamp = Math.max(...allDates);

            const timelineStart = new Date(minTimestamp);
            timelineStart.setDate(1); // Start timeline at the beginning of the first conflict month
            timelineStart.setMonth(timelineStart.getMonth()); // Keep the month

            const timelineEnd = new Date(maxTimestamp);
            timelineEnd.setDate(1); // End timeline at the beginning of the month *after* the last conflict
            timelineEnd.setMonth(timelineEnd.getMonth() + 1);


            const totalDuration = timelineEnd.getTime() - timelineStart.getTime();

            // Update timeline labels
            const formatDateLabel = (date) => date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            startDateLabel.textContent = formatDateLabel(timelineStart);
            endDateLabel.textContent = formatDateLabel(timelineEnd);

            // --- Populate Legend ---
            legend.innerHTML = '<h4>Color Coded Legend</h4>'; // Reset header
            conflictData.forEach(conflict => {
                const item = document.createElement('div');
                item.classList.add('legend-item');
                item.innerHTML = `
                    <span class="legend-color" style="background-color: ${conflict.color};"></span>
                    ${conflict.title}
                `;
                legend.appendChild(item);
            });

            // --- Create Markers ---
            conflictData.forEach(conflict => {
                conflict.keyDates.forEach((dateStr) => {
                    const date = new Date(dateStr);
                    const datePos = date.getTime() - timelineStart.getTime();
                    // Ensure division by zero doesn't happen if duration is 0
                    const percentage = totalDuration > 0 ? (datePos / totalDuration) * 100 : 0;

                    if (percentage >= 0 && percentage <= 100) {
                        // Store marker data for snapping
                        markerData.push({ percent: percentage, conflictId: conflict.id });

                        const marker = document.createElement('div');
                        marker.classList.add('timeline-marker');
                        marker.style.left = `${percentage}%`;
                        marker.style.backgroundColor = conflict.color;
                        marker.dataset.conflictId = conflict.id;
                        marker.dataset.date = dateStr;

                        timelineTrack.appendChild(marker);

                        // Add hover and click listeners to markers
                        marker.addEventListener('mouseenter', (event) => {
                            const conflict = conflictData.find(c => c.id === parseInt(event.target.dataset.conflictId));
                            if (conflict) {
                                const date = event.target.dataset.date;
                                updateDisplays(conflict, date);
                            }
                        });

                        // Add click/tap handler
                        marker.addEventListener('click', (event) => {
                            const conflict = conflictData.find(c => c.id === parseInt(event.target.dataset.conflictId));
                            if (conflict) {
                                const date = event.target.dataset.date;
                                updateDisplays(conflict, date);
                                // Update slider position to match clicked marker
                                slider.value = Math.round(percentage * 10.0);
                            }
                        });
                    }
                });
            });
             // Sort marker data by percentage for easier snapping calculation
             markerData.sort((a, b) => a.percent - b.percent);
            
            // Start with slider at 0 instead of snapping to first marker
            slider.value = 0;
            updateDisplays(null); // Clear displays initially

            // Start with first marker's data if available
            if (markerData.length > 0) {
                const firstMarker = markerData[0];
                const firstConflict = conflictData.find(c => c.id === firstMarker.conflictId);
                if (firstConflict) {
                    updateDisplays(firstConflict, firstConflict.keyDates[0]);
                    slider.value = Math.round(firstMarker.percent * 10.0);
                }
            }
        }

        function updateDisplays(conflict, date = null) {
            const summaryDisplay = document.getElementById('summaryDisplay');

            if (conflict) {
                summaryDisplay.innerHTML = conflict.summary;
            } else {
                summaryDisplay.innerHTML = '<p>Move the slider to a marker to see conflict details.</p><p> Use the arrow keys to quickly iterate over the date markers.</p>';
            }
        }

        // --- Slider Interaction ---
        slider.addEventListener('input', (event) => {
            const sliderValue = parseFloat(slider.value);
            const sliderPercent = sliderValue / 10.0;
            let closestMarker = null;
            let minDistance = Infinity;

            for (const markerInfo of markerData) {
                const distance = Math.abs(sliderPercent - markerInfo.percent);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMarker = markerInfo;
                }
            }

            if (closestMarker && minDistance < 2.0) {
                const conflict = conflictData.find(c => c.id === closestMarker.conflictId);
                if (conflict) {
                    const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${closestMarker.percent}%"]`);
                    const date = marker ? marker.dataset.date : null;
                    updateDisplays(conflict, date);
                }
            } else {
                updateDisplays(null);
            }
        });

        slider.addEventListener('change', () => {
            const sliderValue = parseFloat(slider.value);
            const currentPercent = sliderValue / 10.0;
            let closestMarkerPercent = markerData[0].percent; // Default to first marker
            let minDistance = Math.abs(currentPercent - markerData[0].percent);

            // Find the closest marker
            markerData.forEach(markerInfo => {
                const distance = Math.abs(currentPercent - markerInfo.percent);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMarkerPercent = markerInfo.percent;
                }
            });

            // Always snap to closest marker
            const snappedValue = Math.round(closestMarkerPercent * 10.0);
            slider.value = snappedValue;

            // Show summary for snapped position
            const snappedPercent = snappedValue / 10.0;
            const markerInfo = markerData.find(m => Math.abs(m.percent - snappedPercent) < 0.1);
            if (markerInfo) {
                const conflict = conflictData.find(c => c.id === markerInfo.conflictId);
                if (conflict) {
                    const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${markerInfo.percent}%"]`);
                    const date = marker ? marker.dataset.date : null;
                    updateDisplays(conflict, date);
                }
            }
        });

        slider.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
                
                const currentValue = parseFloat(slider.value);
                const currentPercent = currentValue / 10.0;
                
                let nextMarker;
                if (event.key === 'ArrowRight') {
                    nextMarker = markerData.find(marker => marker.percent > currentPercent + 0.1);
                    if (!nextMarker && currentPercent < 0.1) {
                        nextMarker = markerData[0];
                    }
                } else {
                    nextMarker = markerData.reverse().find(marker => marker.percent < currentPercent - 0.1);
                    markerData.reverse();
                    if (!nextMarker && currentPercent > 99.9) {
                        nextMarker = markerData[markerData.length - 1];
                    }
                }

                if (nextMarker) {
                    slider.value = Math.round(nextMarker.percent * 10.0);
                    const conflict = conflictData.find(c => c.id === nextMarker.conflictId);
                    if (conflict) {
                        const marker = document.querySelector(`.timeline-marker[data-conflict-id="${conflict.id}"][style*="left: ${nextMarker.percent}%"]`);
                        const date = marker ? marker.dataset.date : null;
                        updateDisplays(conflict, date);
                    }
                }
            }
        });

        // Add touch swipe handling
        let touchStartX = 0;
        let touchEndX = 0;
        
        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
        }, false);
        
        document.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        }, false);
        
        function handleSwipe() {
            const swipeThreshold = 50;
            const diff = touchEndX - touchStartX;
            
            if (Math.abs(diff) < swipeThreshold) return;
            
            // Simulate arrow key press based on swipe direction
            const event = new KeyboardEvent('keydown', {
                key: diff > 0 ? 'ArrowLeft' : 'ArrowRight'
            });
            slider.dispatchEvent(event);
        }

        // Initialize on load
        initializeTimeline();

        // Re-initialize on window resize to adjust marker positions
        window.addEventListener('resize', initializeTimeline);

    </script>

</body>
</html>
